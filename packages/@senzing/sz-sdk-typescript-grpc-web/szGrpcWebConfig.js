"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SzGrpcWebConfig = void 0;
const szconfig_web_pb_1 = require("./szconfig/szconfig_web_pb");
const szconfig_web_client_1 = require("./szconfig/szconfig_web_client");
const szHelpers_1 = require("./szHelpers");
const SzError_1 = require("./senzing/SzError");
const szGrpcWebEnvironment_1 = require("./szGrpcWebEnvironment");
const szGrpcWebBase_1 = require("./abstracts/szGrpcWebBase");
/**
 * SzConfig
 * Access the Senzing Config module via gRPC
 * @group SzGrpcClasses
 * @hideconstructor
 * @class
 */
class SzGrpcWebConfig extends szGrpcWebBase_1.SzGrpcWebBase {
    get definition() {
        return this._definition;
    }
    set definition(value) {
        this._definition = value;
    }
    /**
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    set client(value) {
        this._client = value;
    }
    /**
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    get client() {
        return this._client;
    }
    constructor(parameters) {
        const { connectionString, credentials, definition, client, grpcOptions, grpcConnectionReadyTimeOut } = parameters;
        super(parameters);
        /** See {@link https://github.com/senzing-garage/knowledge-base/blob/main/lists/senzing-component-ids.md} */
        this.productId = "5050";
        // assign configDefinition to work with
        this._definition = definition;
        if (client) {
            // if client was passed in use/reuse that
            this._client = client;
        }
        else if (connectionString) {
            // otherwise create client from options passed in
            this._client = new szconfig_web_client_1.SzConfigClient(connectionString ? connectionString : szGrpcWebEnvironment_1.DEFAULT_CONNECTION_STRING, credentials ? credentials : szGrpcWebEnvironment_1.DEFAULT_CREDENTIALS, grpcOptions ? grpcOptions : szGrpcWebEnvironment_1.DEFAULT_CHANNEL_OPTIONS);
        }
        else {
            // no client or connection params, throw
            throw new Error(`not enough parameters to initialize`);
        }
    }
    /**
     * Adds a data source to an existing in-memory configuration.
     * @param dataSourceCode Name of data source code to add.
     * @returns {Promise<string>} JSON document listing the newly created data source
     */
    registerDataSource(dataSourceCode) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfig_web_pb_1.RegisterDataSourceRequest();
                request.setConfigDefinition(this.definition);
                request.setDataSourceCode(dataSourceCode);
                this.client.registerDataSource(request, this._metadata, (err, res) => {
                    if (err) {
                        reject((0, szHelpers_1.newException)(err));
                        return;
                    }
                    let result = res.getResult();
                    // update config definition with updated result
                    this.definition = res.getConfigDefinition();
                    resolve(result);
                });
            });
        });
    }
    /**
     * Adds multiple data sources to an existing in-memory configuration.
     * @param {string[]} dataSourceCodes
     * @returns {Promise<string[]>} JSON documents for each datasource listing the newly created data source
     */
    registerDataSources(dataSourceCodes) {
        /**
         * Attempting to create multiple datasources asynchronously ends up causing a connection closed error.
         * JavaScript/TypeScript does not have a good paradigm for synchronously requesting promises one after the other.
         * (technically we could use generators but google's protoc generated files do not support ESM which would be required for
         * using "async" and "await" so that leaves us with recursive function calls). Asking the end user to come up
         * with that logic on their own might be a bit daunting so I'm providing this convenience method that
         * handles it for them.
         */
        /** private class used for managing sequential requests */
        let addDataSourcesSequentially = (dataSources, callback) => {
            let _dataSources = dataSources;
            let _callback;
            let _onComplete;
            let _responses = [];
            // define subs
            let next = () => {
                let dsName = _dataSources.shift();
                if (!dsName || dsName == undefined) {
                    // we're done
                    onComplete();
                    return;
                }
                //return new Promise((resolve, reject) => {
                this.registerDataSource(dsName)
                    .then((resp) => {
                    // add response to results
                    _responses.push(resp);
                    // call "getNextRequest" again
                    next();
                });
                //})
            };
            let onComplete = () => {
                // when we're done call this method
                if (_callback) {
                    _callback.call(this, _responses);
                }
            };
            // initialization logic
            if (callback) {
                _callback = callback;
            }
            // set up onComplete promise now that we know the number of requests
            _onComplete = new Promise((resolve, reject) => {
                if (_responses.length >= _dataSources.length) {
                    resolve(_responses);
                }
            });
            // if there's a callback attach it to the _onComplete promise chain
            if (callback) {
                _onComplete.then(callback);
            }
            // kick off the first request. (recursive method chain)
            if (_dataSources && _dataSources.length > 0) {
                next();
            }
        };
        return new Promise((resolve, reject) => {
            let addDataSources = addDataSourcesSequentially(dataSourceCodes, (results, error) => {
                if (error) {
                    reject(error);
                }
                resolve(results);
            });
        });
    }
    /**
     * Removes a data source from an existing in-memory configuration.
     * or {@link SzGrpcConfig#importConfig} methods.
     * @param dataSourceCode Name of data source code to delete.
     * @returns {Promise<undefined>} for async flow control
     */
    unregisterDataSource(dataSourceCode) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfig_web_pb_1.UnregisterDataSourceRequest();
                request.setConfigDefinition(this.definition);
                request.setDataSourceCode(dataSourceCode);
                this.client.unregisterDataSource(request, this._metadata, (err, res) => {
                    if (err) {
                        reject((0, szHelpers_1.newException)(err));
                        return;
                    }
                    this.definition = res.getConfigDefinition();
                    //console.log("RESPONSE:\n\r", result);
                    resolve(true);
                });
            });
        });
    }
    /**
     * Returns a JSON document of data sources contained in an in-memory configuration.
     * @returns {Promise<{DSRC_ID: number, DSRC_CODE: string}[]>} containing a JSON document listing all of the data sources.
     */
    getDataSourceRegistry() {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfig_web_pb_1.GetDataSourceRegistryRequest();
                request.setConfigDefinition(this.definition);
                this.client.getDataSourceRegistry(request, this._metadata, (err, res) => {
                    if (err) {
                        reject((0, szHelpers_1.newException)(err));
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    let result = res.getResult();
                    try {
                        if (result) {
                            let retValJSON = JSON.parse(result);
                            if (retValJSON && retValJSON['DATA_SOURCES']) {
                                resolve(retValJSON['DATA_SOURCES']);
                            }
                        }
                    }
                    catch (err) { }
                    resolve(JSON.parse(res.getResult()));
                });
            });
        });
    }
    /**
     * @param configDefinition
     * @returns {Promise<boolean>}
     */
    verifyConfig(configDefinition) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfig_web_pb_1.VerifyConfigRequest();
                request.setConfigDefinition(configDefinition ? configDefinition : this.definition);
                this.client.verifyConfig(request, this._metadata, (err, res) => {
                    if (err) {
                        reject((0, szHelpers_1.newException)(err));
                        return;
                    }
                    resolve(res.getResult());
                });
            });
        });
    }
}
exports.SzGrpcWebConfig = SzGrpcWebConfig;
//# sourceMappingURL=szGrpcWebConfig.js.map