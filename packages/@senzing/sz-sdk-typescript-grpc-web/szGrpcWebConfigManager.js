"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SzGrpcWebConfigManager = void 0;
const szconfigmanager_web_pb_1 = require("./szconfigmanager/szconfigmanager_web_pb");
const szconfigmanager_web_client_1 = require("./szconfigmanager/szconfigmanager_web_client");
const szHelpers_1 = require("./szHelpers");
const SzError_1 = require("./senzing/SzError");
const szGrpcWebEnvironment_1 = require("./szGrpcWebEnvironment");
const szGrpcWebBase_1 = require("./abstracts/szGrpcWebBase");
// alias the concretes to allow copy+paste of code from "SzGrpcConfig"
const szGrpcWebConfig_1 = require("./szGrpcWebConfig");
/**
 * SzGrpcConfigManager
 * Access the Senzing ConfigManager module via gRPC
 *
 * @group SzGrpcClasses
 * @hideconstructor
 * @class
 */
class SzGrpcWebConfigManager extends szGrpcWebBase_1.SzGrpcWebBase {
    /**
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: module:SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    set client(value) {
        this._client = value;
    }
    /**
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: module:SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    get client() {
        return this._client;
    }
    /**
     * @internal
     */
    get grpcParameters() {
        let res = this._parameters;
        return res;
    }
    constructor(parameters) {
        const { connectionString, credentials, client, configClient, grpcOptions, isTestEnvironment, grpcConnectionReadyTimeOut } = parameters;
        super(parameters);
        /** See {@link https://github.com/senzing-garage/knowledge-base/blob/main/lists/senzing-component-ids.md} */
        this.productId = "5051";
        /**
         * used for telling classes not to use live clients
         * @ignore */
        this.isTestEnvironment = false;
        this._parameters = parameters;
        if (isTestEnvironment !== undefined) {
            this.isTestEnvironment = isTestEnvironment;
        }
        if (configClient) {
            this._configClient = configClient;
        }
        if (client) {
            // if client was passed in use/reuse that
            this._client = client;
        }
        else if (connectionString) {
            // otherwise create client from options passed in
            this._client = new szconfigmanager_web_client_1.SzConfigManagerClient(connectionString ? connectionString : szGrpcWebEnvironment_1.DEFAULT_CONNECTION_STRING, credentials ? credentials : szGrpcWebEnvironment_1.DEFAULT_CREDENTIALS, grpcOptions ? grpcOptions : szGrpcWebEnvironment_1.DEFAULT_CHANNEL_OPTIONS);
        }
        else {
            // no client or connection params, throw
            throw new Error(`not enough parameters to initialize`);
        }
    }
    /** @internal */
    createConfig(definitionOrConfigId) {
        if (this.isTestEnvironment) {
            return this.createConfigForTests();
        }
        if (definitionOrConfigId) {
            if (typeof definitionOrConfigId == 'number') {
                // get new SzConfig from configId
                return this.createConfigFromConfigId(definitionOrConfigId);
            }
            else {
                // get new SzConfig from configDefinition
                return this.createConfigFromDefinition(definitionOrConfigId);
            }
        }
        // when no args get from template
        return this.createConfigFromTemplate();
    }
    /**
     * Get the Configuration Document for the default configuration template.
     * @returns {Promise<string>} the configuration document
     */
    getTemplateConfig() {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfigmanager_web_pb_1.GetTemplateConfigRequest();
                this.client.getTemplateConfig(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(res.getResult());
                });
            });
        });
    }
    /**
     * Registers the configuration described by the specified
     * configuration definition in the repository with the specified
     * comment. If a comment has not been provided an autogenerated one will be used.
     * @param configDefinition The configuration definition to register.
     * @param comment The comments for the configuration.
     * @returns {Promise<void>} The identifier for referencing the config in the entity repository.
     *
     * @throws SzException If a failure occurs.
     */
    registerConfig(configDefinition, comment) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfigmanager_web_pb_1.RegisterConfigRequest();
                request.setConfigDefinition(configDefinition);
                if (comment)
                    request.setConfigComment(comment);
                this.client.registerConfig(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(res.getResult());
                });
            });
        });
    }
    /**
     * Gets the list of saved configuration ID's with their comments and
     * timestamps and return the JSON describing them.
     *
     * @returns {Promise<string>} JSON document describing the configurations registered
     * in the entity repository with their identifiers, timestamps and comments.
     */
    getConfigRegistry() {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfigmanager_web_pb_1.GetConfigRegistryRequest();
                this.client.getConfigRegistry(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(res.getResult());
                });
                return undefined;
            });
        });
    }
    /**
     * Gets the configuration ID of the default configuration for the repository
     * and returns it.  If the entity repository is in the initial state and the
     * default configuration ID has not yet been set, then zero (0) is returned.
     * @returns {Promise<number>} identifier which identifies the current configuration in use.
     */
    getDefaultConfigId() {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfigmanager_web_pb_1.GetDefaultConfigIdRequest();
                this.client.getDefaultConfigId(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    //console.log("RESPONSE:\n\r", result);
                    resolve(res.getResult());
                });
            });
            return -1;
        });
    }
    /** @internal */
    setDefaultConfig(configDefinition, comment) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfigmanager_web_pb_1.SetDefaultConfigRequest();
                request.setConfigDefinition(configDefinition);
                if (comment)
                    request.setConfigComment(comment);
                this.client.setDefaultConfig(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    resolve(res.getResult());
                });
            });
        });
    }
    /**
     * Sets the default configuration for the repository to the specified
     * configuration ID.
     *
     * @see replaceDefaultConfigId
     * @param configId The configuration identifier of the Senzing Engine configuration to use as the default.
     * @returns {Promise<undefined>} for async flow control
     */
    setDefaultConfigId(configId) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfigmanager_web_pb_1.SetDefaultConfigIdRequest();
                request.setConfigId(configId);
                this.client.setDefaultConfigId(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    resolve(configId);
                });
            });
        });
    }
    /**
     * Replaces the old configuration identifier with a new configuration identifier
     * in the Senzing database. It is like a “compare-and-swap” instruction to serialize
     * concurrent editing of configuration. If {@param currentDefaultConfigId} is no longer
     * the “current configuration identifier”, the operation will fail. To simply set
     * the default configuration ID, use {@link setDefaultConfigId}.
     *
     * @param currentDefaultConfigId The configuration identifier to replace.
     * @param newDefaultConfigId  The configuration identifier to use as the default.
     * @returns {Promise<undefined>} for async flow control
     */
    replaceDefaultConfigId(currentDefaultConfigId, newDefaultConfigId) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfigmanager_web_pb_1.ReplaceDefaultConfigIdRequest();
                request.setCurrentDefaultConfigId(currentDefaultConfigId);
                request.setNewDefaultConfigId(newDefaultConfigId);
                this.client.replaceDefaultConfigId(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                });
            });
        });
    }
    // ------------------------------- non public methods -------------------------------
    /** @internal */
    get szConfigGrpcOptions() {
        let _options = this.grpcParameters;
        delete _options.client;
        if (this._configClient)
            _options.client = this._configClient;
        return _options;
    }
    /** @internal */
    createConfigFromDefinition(configDefinition) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const res = new szGrpcWebConfig_1.SzGrpcWebConfig(this.szConfigGrpcOptions);
                res.definition = configDefinition;
                res.verifyConfig();
                resolve(res);
            });
        });
    }
    /** @internal */
    createConfigFromConfigId(configId) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szconfigmanager_web_pb_1.GetConfigRequest();
                request.setConfigId(configId);
                this.client.getConfig(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let configDefinition = res.getResult();
                    const conf = new szGrpcWebConfig_1.SzGrpcWebConfig(this.szConfigGrpcOptions);
                    conf.definition = configDefinition;
                    resolve(conf);
                });
            });
        });
    }
    /** @internal */
    createConfigFromTemplate() {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                //const res = new SzGrpcConfig(this.grpcParameters as SzGrpcConfigOptions);
                //res.configDefinition = configDefinition;
                //res.verifyConfig();
                //resolve(res);
                const request = new szconfigmanager_web_pb_1.GetTemplateConfigRequest();
                this.client.getTemplateConfig(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let configDefinition = res.getResult();
                    const conf = new szGrpcWebConfig_1.SzGrpcWebConfig(this.szConfigGrpcOptions);
                    conf.definition = configDefinition;
                    //console.log("RESPONSE:\n\r", result);
                    resolve(conf);
                });
            });
        });
    }
    /**
     * Used for unit tests, avoids needing live grpc client connection
     * @ignore
     */
    createConfigForTests() {
        return new Promise((resolve, reject) => {
            const conf = new szGrpcWebConfig_1.SzGrpcWebConfig(this.szConfigGrpcOptions);
            resolve(conf);
        });
    }
}
exports.SzGrpcWebConfigManager = SzGrpcWebConfigManager;
//# sourceMappingURL=szGrpcWebConfigManager.js.map