"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SzGrpcWebDiagnostic = void 0;
const szdiagnostic_web_pb_1 = require("./szdiagnostic/szdiagnostic_web_pb");
const szdiagnostic_web_client_1 = require("./szdiagnostic/szdiagnostic_web_client");
const szHelpers_1 = require("./szHelpers");
const SzError_1 = require("./senzing/SzError");
const szGrpcWebEnvironment_1 = require("./szGrpcWebEnvironment");
const szGrpcWebBase_1 = require("./abstracts/szGrpcWebBase");
/**
 * SzGrpcDiagnostic
 * Access the Senzing Diagnostic module via gRPC
 *
 * @group SzGrpcClasses
 * @hideconstructor
 * @class
 */
class SzGrpcWebDiagnostic extends szGrpcWebBase_1.SzGrpcWebBase {
    /**
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: module:SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    set client(value) {
        this._client = value;
    }
    /**
     * the client is the grpc client class generated by protoc.
     * Not intended for end-user use. We need these in case we have to re-connect or destroy from {@link: module:SzGrpcEnvironment} but shouldn't be in the docs.
     * @ignore
     */
    get client() {
        return this._client;
    }
    constructor(parameters) {
        const { connectionString, credentials, client, grpcOptions, grpcConnectionReadyTimeOut } = parameters;
        super(parameters);
        /** See {@link https://github.com/senzing-garage/knowledge-base/blob/main/lists/senzing-component-ids.md} */
        this.productId = "5052";
        if (client) {
            // if client was passed in use/reuse that
            this._client = client;
        }
        else if (connectionString) {
            // otherwise create client from options passed in
            this._client = new szdiagnostic_web_client_1.SzDiagnosticClient(connectionString ? connectionString : szGrpcWebEnvironment_1.DEFAULT_CONNECTION_STRING, credentials ? credentials : szGrpcWebEnvironment_1.DEFAULT_CREDENTIALS, grpcOptions ? grpcOptions : szGrpcWebEnvironment_1.DEFAULT_CHANNEL_OPTIONS);
        }
        else {
            // no client or connection params, throw
            throw new Error(`not enough parameters to initialize`);
        }
    }
    /**
     * Performs inserts to determine rate of insertion.
     * @param secondsToRun Duration of the test in seconds.
     * @returns {Promise<CHECK_DATASTORE_PERFORMANCE_RESPONSE>} A JSON document
     */
    checkRepositoryPerformance(secondsToRun) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szdiagnostic_web_pb_1.CheckRepositoryPerformanceRequest();
                request.setSecondsToRun(secondsToRun);
                this.client.checkRepositoryPerformance(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let result = JSON.parse(res.getResult());
                    //console.log("RESPONSE:\n\r", result, res.getResult().toString());
                    resolve(result);
                });
            });
        });
    }
    /**
     * Returns details of the datastore currently in use by Senzing.
     * @returns {Promise<string>}
     */
    getRepositoryInfo() {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szdiagnostic_web_pb_1.GetRepositoryInfoRequest();
                this.client.getRepositoryInfo(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let result = res.getResult();
                    //console.log("RESPONSE:\n\r", result);
                    resolve(result);
                });
            });
        });
    }
    /**
     * Returns diagnostic information of a feature. Not recommended for use.
     * @experimental
     * @param featureId The identifier of the feature to describe.
     * @returns {Promise<string>} A string containing a JSON document
     */
    getFeature(featureId) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szdiagnostic_web_pb_1.GetFeatureRequest();
                request.setFeatureId(featureId);
                this.client.getFeature(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    let result = res.getResult();
                    //console.log("RESPONSE:\n\r", result);
                    resolve(result);
                });
            });
        });
    }
    /**
     * Removes every record in the Senzing repository.
     * @returns {Promise<undefined>} for async flow control.
     */
    purgeRepository() {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szdiagnostic_web_pb_1.PurgeRepositoryRequest();
                this.client.purgeRepository(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    resolve(undefined);
                });
            });
        });
    }
    /**
     * Used by {@link SzGrpcEnvironment}. Not intended to be called directly by end-users.
     * @ignore
     * @param configId
     */
    reinitialize(configId) {
        return new Promise((resolve, reject) => {
            if (!this.client) {
                reject(new SzError_1.SzNoGrpcConnectionError());
                return;
            }
            this.waitForReady(this.getDeadlineFromNow(), (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                const request = new szdiagnostic_web_pb_1.ReinitializeRequest();
                request.setConfigId(configId);
                this.client.reinitialize(request, this._metadata, (err, res) => {
                    if (err) {
                        let _err = (0, szHelpers_1.newException)(err);
                        reject(_err);
                        throw _err;
                        return;
                    }
                    resolve(undefined);
                });
            });
        });
    }
}
exports.SzGrpcWebDiagnostic = SzGrpcWebDiagnostic;
//# sourceMappingURL=szGrpcWebDiagnostic.js.map